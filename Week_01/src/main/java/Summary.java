/**
 * @author Echo
 * @date 2020/5/24 9:25 上午
 */
public class Summary {


    /**
      第一周总结：

        心法：1.学习算法 三份看 七分练
             2.切记死磕，不要在一个问题上浪费太多时间
             3.练习时 过遍数，切记不要只练一次了事，参考五毒神掌
             4.学习leetcode上的大牛解法，在对比中感受伤害，在伤害中不断成长
             5.发挥司机应配的特长，把解题过程记住

             学习一门知识的三个通用步骤：
             1.拆解知识点
             2.逐个击破
             3.形成反馈（主动 or 被动）

             数据结构与算法的知识点拆解：
             1.一维数据结构：数组、链表、栈、队列、双端队列、优先级队列、集合、映射
             2.二维数据结构：跳跃表、树、图、二叉树、AVL树、红黑树、B/B+树、线段树、字段树、堆、并查集
             3.算法基础操作：if/else/switch..case/for/while/recursion
             4.算法：搜索/深度优先搜索/广度优先搜索/动态规划/贪心算法/二分查找

             获取反馈的方式和途径：
             1.看博客与Leetcode评论
             2.与同学、老师、助教交流
             3.内容输出：笔记、博客 or 讲课分享

             切题四件套：
             1.确认题目要求
             2.考虑所有可能的解法并对比
             3.编码
             4.调试、测试

             五毒神掌：
             1.花5-15分钟读题并考虑解题方法，没有思路立马看答案 并 理解记住
             2.马上再默写一遍
             3.过一天在默写一遍
             4.过一周再默写一遍
             5.面试前在过一遍

        数据结构与算法总结：
            数组：是一个有限的、连续的内存空间，基于索引的随机查找的时间复杂度为O(1)、插入、删除（维持顺序）的时间复杂度为O(n)
            链表：没有空间上的限制，内存不连续， 随机查找的时间复杂度为O(n)、插入删除的时间复杂度为O(1)
            跳跃表：通过升维和以空间换时间的方式来提高有序链表的相关操作的效率，插入删除查找的时间复杂度为O(logn)
            栈：一种先进后出的数据结构，是线性表的一个子集、一般用在实现特定功能或辅助某些算法的实现，可以通过数组和链表来实现
            队列：一种先进先出的数据结构，也是线性表的一个子集，可以通过数组、链表来实现，优先级队列还可以通过堆来实现

            两数之和: 暴力求解 两层循环
            三数之和：1、暴力请求 三层循环，2、双指针夹B法
            移动零：1、利用额外数组将非0和0分为放到辅助数组的两边，2、将所有非0数移动到前面，剩余的补0，3、位置交换
            爬楼梯：1、套用斐波那契数列递推公式（存在重复计算），2、记录3个数，一次累加，向前推进
            盛最多水的容器：1、两层循环 暴力求解，2、双指针夹B法，取较小的高*宽，max最大值
            翻转链表：1、递归 node.next.next = node, node.next = null，2、循环 依次翻转
            环形链表-判断是否有环：1、循环遍历 + set 判断是否存在node，2、快慢指针
            环形链表-找到入环节点：
            有效括号：利用栈进行匹配，左括号入栈，右括号与栈顶元素对比，匹配则弹栈，最后判断栈是否为空
            最小栈：双栈，一个基于栈数据，一个记录最小值，实现查找最小值的O(1)时间复杂度


            作业：
            1.合并两个有序链表
            2.数组翻转
            3.删除数组中的重复元素
            4.合并两个有序数组
            5.两数之和
            6.移动0
            7.设计循环队列

            8.用add first 和 add last改写 Dequeue -> homework.RewriteDeque
            9.对Java中PriorityQueue的分析：
                Java中的PriorityQueue底层是通过堆来实现的，这个堆是利用数组存储数据，创建时，需要
                指定一个Comparator来定义数据的优先级规则，向优先级队列中添加数据是，是先将数据添加到
                底层数组的末尾，然后再执行shiftUp操作，来维持堆的特性，从队列中拿数据时，是以O(1)的时间
                复杂度从堆定拿数据，然后再把数组末尾数据移动到头部，最后执行shiftDown操作，维持整个堆的特性
      */
}
